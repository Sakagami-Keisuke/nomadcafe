        #docker-composeのバージョン(2020.4.12時点では"3")
version: '3'
        #servicesは各コンテナを定義します
services:
        #dbは1つのコンテナ名です（１コンテナ１プロセス）
        #ローカルでmysql --version確認 → mysql  Ver 14.14 Distrib 5.6.47
        #DockerHubでmysql5.6を確認できたので5.6と記述
  db:
    image: mysql:5.6
        #environmentは環境変数を追加します
        #環境変数MYSQL_ROOT_PASSWORDに、今回はpasswordと入れます（パスは自由）
        #パスワードの直打ちは危険なので、環境変数を作って秘匿対応します
    environment:
      MYSQL_ROOT_PASSWORD: 'password'
        #portsは公開用のポートで、ホスト側とコンテナ側の両方のポートを指定します（ ホスト側:コンテナ側 ）
        #ローカルMYSQLは確認すると3306を使用中なので、ホスト側を4306にします（4に深い意味はありません）
        #ローカル側MYSQLは大抵は自動で3306になっているようです
        #Sequelproにて4036を指定すると、DockerのMYSQLがSequelproで見れるようになり便利ですね！
    ports:
      - "4306:3306"
      #webはコンテナ名（１コンテナ１プロセス）
      #buildはdockercompose.ymlを基点に指定フォルダー配下のDockerfileを元にコンテナを作成します。
      #指定は .  ルート
  web:
    build: .
      #commandは任意にコマンドを上書きできます。
      #bashはOS カーネルとユーザの橋渡しするプログラムシェル
      #起動停止の繰り返しで起こる「A server is already running.」エラー原因のpidをbuildのたび削除する（unicorn master KILLと同じ）
      #Rails serverを立ち上げた際にURL(http://0.0.0.0:3000)にアクセス
    command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails s -p 3000 -b '0.0.0.0'"
      #volumesではパスを指定するとDockerエンジンはボリュームを作成します
      #カレントディレクトリ(.)をapp_nameディレクトリにマウントします。
      #データが保存されるとローカルのファイルとして残るので、仮にコンテナが消えてもデータは永続化できます。
    volumes:
      - .:/app_name
      #portsは公開用のポートのことでホスト側とコンテナ側の両方のポートを指定します（ ホスト側:コンテナ側 ）
    ports:
      - "3000:3000"
      #depends_onはサービス間の依存関係を指定します
      #docker-compose up を実行したら、web: コンテナプロセスを開始する前に db を先に実行します
    depends_on:
      - db
